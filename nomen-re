#!/usr/bin/perl
use strict;
use warnings;

use Data::Dumper::Concise;
use Bit::Vector;
use Data::PowerSet;

# Fetch the word to parse.
my $word = shift || 'abioticaly'; # Test cases: 'xyyy'; #'xlylyly';
my $WLEN = length $word;
warn "word: $word ($WLEN)\n";

# Populate word-part regular expression lexicon.
my $lex = {};
for (<DATA>) {
    chomp;
    my ($re, $defn) = split /\s+/, $_, 2;
    $lex->{$re} = { defn => $defn, re => qr/$re/ };
}

# Find the known word-part positions.
my ($known, $mask_id) = get_knowns($word, $lex);
#die Dumper
#$known
##
#map { $known->{$_}{part} }
#    sort { $known->{$a}{span}[0] <=> $known->{$b}{span}[0]
#        || $known->{$a}{span}[1] <=> $known->{$b}{span}[1] } keys %$known
##
#map { $known->{$_}{part} => $known->{$_}{span} } keys %$known
##
#map { "$_ => $mask_id->{$_}" } sort { $b <=> $a } keys %$mask_id
#;

my $combos = power($mask_id);
my $score  = score($combos);
#warn Dumper $score;
warn Dumper $score->{ [ sort keys $score ]->[-1] };

sub score {
    # Get the list of combinations.
    my $combos = shift;

    # Declare the score hash.
    my $score = {};

    # Visit each
    my $i = 0;
    for my $c (@$combos) {
        $i++;
        my $together = or_together(@$c);

        # We score that which has been combined...
        my $scored = $together;
        $scored =~ s/1/k/g; # Undigitize
        $scored =~ s/0/u/g; # "
        # Count contiguous chars.
        $scored =~ s/(.)\1*/$1. length $&/ge;
        my @groups = $scored =~ /([ku]\d+)/g;

        my ( $knowns, $unknowns ) = ( 0, 0 );
        my ( $knownc, $unknownc ) = ( 0, 0 );
        for ( @groups ) {
            if ( /k(\d+)/ ) {
                $knowns++;
                $knownc += $1;
            }
            if ( /u(\d+)/ ) {
                $unknowns++;
                $unknownc += $1;
            }
        }

        push @{ $score->{$together} }, "@$c => " . join( ', ', @{ reconstruct( $word, @$c ) } ) . " => $scored => chunks:$knowns/$unknowns, chars:$knownc/$unknownc";
    }

    # 
    return $score;
}

sub power { # Find the "non-overlapping powerset."
    # List if bitmasks.
    my $masks = shift;

    # The bucket for our saved combinations.
    my $combos = [];

    # Get a new powerset generator.
    my $power = Data::PowerSet->new(keys %$mask_id);

    # Decide if the powerset is to save or discard.
    while (my $collection = $power->next) {
#warn "C:@$collection\n";

        # Compare each item against the others.
        my $last = '';
        for my $i (0 .. @$collection - 1) {
            # Set the current mask.
            my $mask = $collection->[$i];

            # First, have a pair of masks.
            if (not $last) {
                $last = $mask;
                next;
            }
            # Skip this collection if any pair overlap.
            elsif (not does_not_overlap($last, $mask)) {
                last;
            }
            # Save this collection if we make it to the end.
            elsif ($i == @$collection - 1) {
                push @$combos, $collection;
            }
        }
    }

    # Hand back the "non-overlapping powerset."
    return $combos;
}

sub get_knowns { # Fingerprint the known word parts.
    my ($word, $lex) = @_;

    # Find the known word-part positions.
    my $known = {};

    # Poor-man's relational integrity:
    my $id = 0;
    my $mask_id = {};

    for my $i (values %$lex) {
        while ($word =~ /$i->{re}/g) {
            # Match positions.
            my ($m, $n) = ($-[0], $+[0]);
            # Get matched word-part.
            my $part = substr $word, $m, $n - $m;

            # Create the part-of-word bitmask.
            my $mask = 0 x $m;                      # Before known
            $mask   .= 1 x (($n - $m) || 1);        # Known part
            $mask   .= 0 x ($WLEN - $n);    # After known

            # Output our progress.
#            warn sprintf "%s %s - %s, %s (%d %d), %s\n",
#                $mask,
#                $i->{re},
#                substr($word, 0, $m),
#                $part,
#                $m,
#                $n - 1,
#                substr($word, $n),
#            ;

            # Save the known as a member of a list keyed by starting position.
            $known->{$id} = {
                part => $part,
                span => [$m, $n - 1],
                defn => $i->{defn},
                mask => $mask,
            };
            # Save the relationship between mask and id.
            $mask_id->{$mask} = $id++;
        }
    }

    return $known, $mask_id;
}

sub does_not_overlap { # Compute whether the given masks overlap.

    # Get our masks to check.
    my ($mask, $check) = @_;

    # Create the bitstrings to compare.
    my $bitmask  = Bit::Vector->new_Bin($WLEN, $mask);
    my $orclone  = Bit::Vector->new_Bin($WLEN, $check);
    my $xorclone = Bit::Vector->new_Bin($WLEN, $check);

    # Compute or and xor for the strings.
    $orclone->Or($bitmask, $orclone);
    $xorclone->Xor($bitmask, $xorclone);

    # Return the "or & xor equivalent sibling."
    return $xorclone->equal($orclone) ? $orclone->to_Bin : 0;
}

sub or_together { # Combine a list of bitmasks.

    # Get our masks to score.
    my @masks = @_;

    # Initialize the bitmask to return, to zero.
    my $result = Bit::Vector->new_Bin($WLEN, (0 x $WLEN));

    for my $mask (@masks) {
        # Create the bitstrings to compare.
        my $bitmask = Bit::Vector->new_Bin($WLEN, $mask);

        # Get the union of the bit strings.
        $result->Or($result, $bitmask);
    }

    # Return the "or sum."
    return $result->to_Bin;
}

sub reconstruct {
    my ( $word, @masks ) = @_;

    my $strings = [];

    for my $mask (reverse sort @masks) {
        my $i = 0;
        my $last = 0;
        my $string  = '';
        for my $m ( split //, $mask ) {
            if ( $m ) {
                $string .= '<' unless $last;
                $string .= substr( $word, $i, 1 );
                $last = 1;
            }
            else {
                $string .= '>' if $last;
                $string .= substr( $word, $i, 1 );
                $last = 0;
            }
            $i++;
        }
        $string .= '>' if $last;
        push @$strings, $string;
    }

    return $strings;
}

__DATA__
a(?=\w) opposite
ab(?=\w) away
bi(?=\w) two
bio(?=\w) life
(?<=\w)al type
(?<=\w)ic belonging
(?<=\w)ly like
(?<=\w)log know
(?<=\w)o(?=\w) combining
(?<=\w)tic possessing
(?<=\w)y like
