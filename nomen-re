#!/usr/bin/perl
use strict;
use warnings;

use Algorithm::Loops 'NestedLoops';
use Bit::Vector;
use lib '../Lingua-TokenParse/lib';
use Lingua::TokenParse;
use List::Compare;

# Fetch the word to parse.
my $word = shift || 'abioticaly'; # Test cases: 'xyyy'; #'xlylyly';
my $WLEN = length $word;
warn "word: $word ($WLEN)\n";

# TODO Use the L::TP built-in method for this.
# Populate word-part regular expression lexicon.
my $lex = {};
for (<DATA>) {
    chomp;
    my ($re, $defn) = split /\s+/, $_, 2;
    $lex->{$re} = { defn => $defn, re => qr/$re/ };
}

my $p = Lingua::TokenParse->new(
    word => $word,
#    lexicon => { map { $lex->{re} => $lex->{defn} } keys %$lex },
);
my $c = $p->build_combinations;
use Data::Dumper;die
Data::Dumper->new([$c])->Indent(1)->Terse(1)->Quotekeys(0)->Sortkeys(1)->Dump;

# Find the known word-part positions.
my ($known, $mask_id) = get_knowns($word, $lex);
#use Data::Dumper;die Data::Dumper->new([$known])->Indent(1)->Terse(1)->Quotekeys(0)->Sortkeys(1)->Dump;
#use Data::Dumper;die Data::Dumper->new([
#map { $known->{$_}{part} }
#    sort { $known->{$a}{span}[0] <=> $known->{$b}{span}[0]
#        || $known->{$a}{span}[1] <=> $known->{$b}{span}[1] } keys %$known
#])->Indent(1)->Terse(1)->Quotekeys(0)->Sortkeys(1)->Dump;
use Data::Dumper;die Data::Dumper->new([
map { $known->{$_}{part} => $known->{$_}{span} } keys %$known
])->Indent(1)->Terse(1)->Quotekeys(0)->Sortkeys(1)->Dump;
#use Data::Dumper;die Data::Dumper->new([
#map { "$_ => $mask_id->{$_}" } sort { $b cmp $a } keys %$mask_id
#])->Indent(1)->Terse(1)->Quotekeys(0)->Sortkeys(1)->Dump;

my $final = [];
my $combos = [];
my $overlaps = {};

combo(keys %$mask_id);
push @$final, $combos;
$combos = [];

for my $part (keys %$overlaps) {
    combo($part, keys %$mask_id);
    push @$final, $combos;
    $combos = [];
}

use Data::Dumper;warn Data::Dumper->new([$final])->Indent(1)->Terse(1)->Quotekeys(0)->Sortkeys(1)->Dump;
#use Data::Dumper;warn Data::Dumper->new([$overlaps])->Indent(1)->Terse(1)->Quotekeys(0)->Sortkeys(1)->Dump;

sub get_knowns {
    my ($word, $lex) = @_;

    # Find the known word-part positions.
    my $known = {};

    # Poor-man's relational integrity:
    my $id = 0;
    my $mask_id = {};

    for my $i (values %$lex) {
        while ($word =~ /$i->{re}/g) {
            # Match positions.
            my ($m, $n) = ($-[0], $+[0]);
            # Get matched word-part.
            my $part = substr $word, $m, $n - $m;

            # Create the part-of-word bitmask.
            my $mask = 0 x $m;                      # Before known
            $mask   .= 1 x (($n - $m) || 1);        # Known part
            $mask   .= 0 x ($WLEN - $n);    # After known

            # Output our progress.
#            warn sprintf "%s %s - %s, %s (%d %d), %s\n",
#                $mask,
#                $i->{re},
#                substr($word, 0, $m),
#                $part,
#                $m,
#                $n - 1,
#                substr($word, $n),
#            ;

            # Save the known as a member of a list keyed by starting position.
            $known->{$id} = {
                part => $part,
                span => [$m, $n - 1],
                defn => $i->{defn},
                mask => $mask,
            };
            # Save the relationship between mask and id.
            $mask_id->{$mask} = $id++;
        }
    }

    return $known, $mask_id;
}

sub combo { # Recursively construct the combo list of lists.
    my ($head, @tail) = @_;
    return 0 unless $head;
    if ($head && !@$combos) {
        push @$combos, $head;
    }
    if (my $union = does_not_overlap($head, $tail[0])) {
        push @$combos, $tail[0];
        combo($union, @tail[1 .. $#tail]);
    }
    else {
        $overlaps->{ $tail[0] }++;
        combo($head, @tail[1 .. $#tail]) if $head && @tail[1 .. $#tail];
    }
}

sub does_not_overlap { # Compute whether the given masks overlap.

    # Get our masks to check.
    my ($mask, $check) = @_;

    # Create the bitstrings to compare.
    my $bitmask  = Bit::Vector->new_Bin($WLEN, $mask);
    my $sibling  = Bit::Vector->new_Bin($WLEN, $check);
    my $xorclone = Bit::Vector->new_Bin($WLEN, $check);

    # Compute or and xor for the strings.
    $sibling->Or($bitmask, $sibling);
    $xorclone->Xor($bitmask, $xorclone);

    # Return whether the or'd sibling equals the xor'd sibling.
    return $xorclone->equal($sibling) ? $sibling->to_Bin : 0;
}

__DATA__
a(?=\w) opposite
ab(?=\w) away
bi(?=\w) two
bio(?=\w) life
(?<=\w)al type
(?<=\w)ic belonging
(?<=\w)ly like
(?<=\w)o(?=\w) combining
(?<=\w)tic possessing
(?<=\w)y like
