#!/usr/bin/perl
use strict;
use warnings;

use Algorithm::Loops 'NestedLoops';
use Bit::Vector;

# Fetch the word to parse.
my $word = shift || 'abiotically'; # Test cases: 'xyyy'; #'xlylyly';
my $WLEN = length $word;
warn "word: $word ($WLEN)\n";

# Populate word-part regular expression lexicon.
my $lex = {};
for (<DATA>) {
    chomp;
    my ($re, $defn) = split /\s+/, $_, 2;
    $lex->{$re} = { defn => $defn, re => qr/$re/ };
}

# Find the known word-part positions.
my ($known, $mask_id) = get_knowns($word, $lex);
#use Data::Dumper;warn Data::Dumper->new([$known])->Indent(1)->Terse(1)->Quotekeys(0)->Sortkeys(1)->Dump;
#use Data::Dumper;die Data::Dumper->new([
#map { "$_ => $mask_id->{$_}" } sort { $b cmp $a } keys %$mask_id
#])->Indent(1)->Terse(1)->Quotekeys(0)->Sortkeys(1)->Dump;

my $combos = combos([keys %$mask_id]);
use Data::Dumper;warn
Data::Dumper->new([$combos])->Indent(1)->Terse(1)->Quotekeys(0)->Sortkeys(1)->Dump;

sub get_knowns {
    my ($word, $lex) = @_;

    # Find the known word-part positions.
    my $known = {};

    # Poor-man's relational integrity:
    my $id = 0;
    my $mask_id = {};

    for my $i (values %$lex) {
        while ($word =~ /$i->{re}/g) {
            # Match positions.
            my ($m, $n) = ($-[0], $+[0]);
            # Get matched word-part.
            my $part = substr $word, $m, $n - $m;

            # Create the part-of-word bitmask.
            my $mask = 0 x $m;                      # Before known
            $mask   .= 1 x (($n - $m) || 1);        # Known part
            $mask   .= 0 x ($WLEN - $n);    # After known

            # Output our progress.
#            warn sprintf "%s %s - %s, %s (%d %d), %s\n",
#                $mask,
#                $i->{re},
#                substr($word, 0, $m),
#                $part,
#                $m,
#                $n - 1,
#                substr($word, $n),
#            ;

            # Save the known as a member of a list keyed by starting position.
            $known->{$id} = {
                part => $part,
                span => [$m, $n - 1],
                defn => $i->{defn},
                mask => $mask,
            };
            # Save the relationship between mask and id.
            $mask_id->{$mask} = $id++;
        }
    }

    return $known, $mask_id;
}

sub does_not_overlap { # Compute whether the given masks overlap.

    # Get our masks to check.
    my ($mask, $check) = @_;

    # Create the bitstrings to compare.
    my $bitmask  = Bit::Vector->new_Bin($WLEN, $mask);
    my $sibling  = Bit::Vector->new_Bin($WLEN, $check);
    my $xorclone = Bit::Vector->new_Bin($WLEN, $check);

    # Compute or and xor for the strings.
    $sibling->Or($bitmask, $sibling);
    $xorclone->Xor($bitmask, $xorclone);

    # Return whether the or'd sibling equals the xor'd sibling.
    return $xorclone->equal($sibling) ? $sibling->to_Bin : 0;
}

sub combos { # Traverse the powerset

    # Get the set over which to iterate.
    my $set = shift;

    # Declare our bucket of non-overlapping combinations.
    my @combos = ();

    # Create and visit each member of the "set of all sets."
    my $next = iter_powerset(@$set);
    while (my @combo = $next->() ) {
#warn "C:'@combo'\n";

        # Set the last member seen to nothing;
        my $last = '';

        # Define our overlap seen flag.
        my $flag = 0;

        # Xor + Or each member with the accumulated.
        for my $member (@combo) {

            # Set the last seen and skip the first member.
            unless ($last) {
                $last = $member;
                next;
            }

            # Set the last seen member but skip the whole combo if the bitstrings overlap.
            unless ($last = does_not_overlap($last, $member)) {

                # Flag this combo as naughty.
                $flag = 1;
            }
        }

        # Skip if this combo has been flagged.
        next if $flag;

        # Add this combo to the non-overlapping set.
        push @combos, \@combo;
    }

    return \@combos;
}

sub iter_powerset { # TODO This algorithm lifted from an as of yet unknown source.
    my @factor = @_;
    my $end = $#factor;
    my @subset = (undef) x $end;
    my ($pos, $mode) = (-1, 1);
    my $return = sub { return @factor[ grep defined, @subset ] };
    my %dispatch = (
        1 => sub {
            ++$pos;
            $subset[ $pos ] = $pos;
            ++$mode if $pos == $end;
            $return->();
        },
        2 => sub {
            $subset[ $pos - 1 ] = undef;
            ++$mode;
            $return->();
        },
        3 => sub {
            $subset[ $pos-- ] = undef;
            while ( $pos >= 0 ) {
                last if defined $subset[ $pos ];
                --$pos;
            }
            $subset[ $pos++ ] = undef;
            return () if ! $pos;
            $subset[ $pos ] = $pos;
            $mode = 1;
            $return->();
        },
    );
    return sub { $dispatch{ $mode }->() };
}

__DATA__
a(?=\w) opposite
ab(?=\w) away
bi(?=\w) two
bio(?=\w) life
(?<=\w)al type
(?<=\w)ic belonging
(?<=\w)ly like
(?<=\w)o(?=\w) combining
(?<=\w)tic possessing
(?<=\w)y like
