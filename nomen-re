#!/usr/bin/perl
use strict;
use warnings;

use Bit::Vector;
#use Bit::Vector::String;

# Fetch the word to parse.
my $word = shift || 'abiotically'; # Test cases: 'xyyy'; #'xlylyly';
my $WLEN = length $word;
warn "word: $word ($WLEN)\n";

# Populate word-part regular expression lexicon.
my $lex = {};
for (<DATA>) {
    chomp;
    my ($re, $defn) = split /\s+/, $_, 2;
    $lex->{$re} = { defn => $defn, re => qr/$re/ };
}

# Find the known word-part positions.
my ($known, $mask_id) = get_knowns($word, $lex);
#use Data::Dumper;die Data::Dumper->new([$known, $mask_id])->Indent(1)->Terse(1)->Quotekeys(0)->Sortkeys(1)->Dump;

# 
my $combo = populate($mask_id);
use Data::Dumper;warn Data::Dumper->new([$combo])->Indent(1)->Terse(1)->Sortkeys(1)->Dump;

sub get_knowns {
    my ($word, $lex) = @_;

    # Find the known word-part positions.
    my $known = {};

    # Poor-man's relational integrity:
    my $id = 0;
    my $mask_id = {};

    for my $i (values %$lex) {
        while ($word =~ /$i->{re}/g) {
            # Match positions.
            my ($m, $n) = ($-[0], $+[0]);
            # Get matched word-part.
            my $part = substr $word, $m, $n - $m;

            # Create the part-of-word bitmask.
            my $mask = 0 x $m;                      # Before known
            $mask   .= 1 x (($n - $m) || 1);        # Known part
            $mask   .= 0 x ($WLEN - $n);    # After known

            # Output our progress.
#            warn sprintf "%s %s - %s, %s (%d %d), %s\n",
#                $mask,
#                $i->{re},
#                substr($word, 0, $m),
#                $part,
#                $m,
#                $n - 1,
#                substr($word, $n),
#            ;

            # Save the known as a member of a list keyed by starting position.
            $known->{$id} = {
                part => $part,
                span => [$m, $n - 1],
                defn => $i->{defn},
                mask => $mask,
            };
            # Save the relationship between mask and id.
            $mask_id->{$mask} = $id++;
        }
    }

    return $known, $mask_id;
}

sub populate { # Associate non-overlaping ids.

    # Use the mask-id hash to create the population list.
    my $mask_id = shift;

    # Bucket of non-overlapping masks.
    my $population = {};

    # For each known mask...
    for my $mask (keys %$mask_id) {

        # Keep track of masks that have been seen.
        my $seen = {};
        # And we have definitely seen this mask.
        $seen->{$mask}++;

        # Prepare for bitwise operations.
        my $bitmask = Bit::Vector->new_Bin($WLEN, $mask);

        # Inspect each unseen mask.
        for my $m (keys %$mask_id) {

            # Skip if this mask has been seen.
            next if $seen->{$m};
            # And we have now seen this "sibling mask."
            $seen->{$m}++;

            # Create the binary operands to compare.
            my $sibling  = Bit::Vector->new_Bin($WLEN, $m);
            my $xorclone = Bit::Vector->new_Bin($WLEN, $m);

            # Compute or and xor.
            $sibling->Or($bitmask, $sibling);
            $xorclone->Xor($bitmask, $xorclone);

            # Save cases where bitwise or equals xor.
            if ($xorclone->equal($sibling)) {
#warn sprintf "* %s => %s\n", $m, $xorclone->String_Export('b');
                push @{ $population->{ $mask_id->{$mask} } }, $mask_id->{$m};
            }
        }
    }

    return $population;
}

__DATA__
a(?=\w) opposite
ab(?=\w) away
bi(?=\w) two
bio(?=\w) life
(?<=\w)ic belonging
(?<=\w)ly like
(?<=\w)o(?=\w) combining
(?<=\w)tic possessing
(?<=\w)y like
