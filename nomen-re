#!/usr/bin/perl
use strict;
use warnings;

use Bit::Vector;
#use Bit::Vector::String;

# Fetch the word to parse.
my $word = shift || 'abiotically'; # Test cases: 'xyyy'; #'xlylyly';
my $WLEN = length $word;
warn "word: $word ($WLEN)\n";

# Populate word-part regular expression lexicon.
my $lex = {};
for (<DATA>) {
    chomp;
    my ($re, $defn) = split /\s+/, $_, 2;
    $lex->{$re} = { defn => $defn, re => qr/$re/ };
}

# Find the known word-part positions.
my ($known, $mask_to_id) = get_knowns($word, $lex);
#use Data::Dumper;die Data::Dumper->new([$known, $mask_to_id])->Indent(1)->Terse(1)->Quotekeys(0)->Sortkeys(1)->Dump;

# 
my $combo = populate($mask_to_id);
#use Data::Dumper;warn Data::Dumper->new([$combo])->Indent(1)->Terse(1)->Sortkeys(1)->Dump;

sub get_knowns {
    my ($word, $lex) = @_;

    # Find the known word-part positions.
    my $known = {};

    # Poor-man's relational integrity:
    my $id = 0;
    my $mask_to_id = {};

    for my $i (values %$lex) {
        while ($word =~ /$i->{re}/g) {
            # Match positions.
            my ($m, $n) = ($-[0], $+[0]);
            # Get matched word-part.
            my $part = substr $word, $m, $n - $m;

            # Create the part-of-word bitmask.
            my $mask = 0 x $m;                      # Before known
            $mask   .= 1 x (($n - $m) || 1);        # Known part
            $mask   .= 0 x ($WLEN - $n);    # After known

            # Output our progress.
#            warn sprintf "%s %s - %s, %s (%d %d), %s\n",
#                $mask,
#                $i->{re},
#                substr($word, 0, $m),
#                $part,
#                $m,
#                $n - 1,
#                substr($word, $n),
#            ;

            # Save the known as a member of a list keyed by starting position.
            $known->{$id} = {
                part => $part,
                span => [$m, $n - 1],
                defn => $i->{defn},
                mask => $mask,
            };
            # Save the relationship between mask and id.
            $mask_to_id->{$mask} = $id++;
        }
    }

    return $known, $mask_to_id;
}

sub populate {
    my $mask_to_id = shift;
    # Bucket of non-overlapping masks.
    my $population = {};
    # For each known mask...
    for my $mask (keys %$mask_to_id) {
        # Keep track of masks that have been seen.
        my $seen = {};
        # And we have definitely seen this mask.
        $seen->{$mask}++;
        $population->{$mask} = {};
        # Prepare for bitwise operations.
        my $bitmask = Bit::Vector->new_Bin($WLEN, $mask);
#        $population = populate_under($mask_to_id, $bitmask, $seen, $population->{$mask}); 
    }
    return $population;
}

sub populate_under {
    my ($mask_to_id, $bitmask, $seen, $population) = @_;
    # Compare to all unseen masks.
    for my $i (keys %$mask_to_id) {
        # Skip if mask has been seen.
        next if $seen->{$i};
        # We have definitely seen this mask.
        $seen->{$i}++;
        # Create the binary operands to compare.
        my $sibling = Bit::Vector->new_Bin($WLEN, $i);
        my $vector = Bit::Vector->new_Bin($WLEN, $i);
        # Compute or and xor.
        $sibling->Or($bitmask, $sibling);
        $vector->Xor($bitmask, $vector);
        # Save cases where bitwise or equals xor.
        if ($vector->equal($sibling)) {
#warn sprintf "* %s => %s\n", $i, $vector->String_Export('b');
            $population->{$i} = populate_under($mask_to_id, $vector, $seen, $population); 
        }
    }
    return $population;
}

__DATA__
a(?=\w) opposite
ab(?=\w) away
bi(?=\w) two
bio(?=\w) life
(?<=\w)ic belonging
(?<=\w)ly like
(?<=\w)o(?=\w) combining
(?<=\w)tic possessing
(?<=\w)y like
